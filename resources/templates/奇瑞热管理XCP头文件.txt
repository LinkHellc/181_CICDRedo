/*
    Start of automatic variable extraction for Measurement/Calibration
    Compile date : Apr 18 2023, time : 13:51:10

There is no guarantee if this tool correctly dump out the necessary contents from ELF file.
Please use the result after very detailed check of the contents!

autoextractdeveloper@gmail.com
*/

/*Calibration_0 Name : [CAL], Start : 0x28081000, Size : 0x00004000*/
/*XCP MASTER CAN ID : 0x6E0, XCP SLAVE CAN ID : 0x6E1, CAN BPS : 500000*/
/*DAQ 0, MaxOdt = 1, Time = 10.000000, CanId = 0x6E1*/
/*DAQ 1, MaxOdt = 1, Time = 100.000000, CanId = 0x6E1*/
/*DAQ 2, MaxOdt = 1, Time = 1000.000000, CanId = 0x6E1*/




ASAP2_VERSION 1 70
/begin PROJECT AutoExtractPrj
	"Generated for Project F:\APP\AutoExtractGui\Sample\test.elf"
	/begin HEADER
		""
		VERSION "000"  PROJECT_NO ASD
	/end HEADER
	/begin MODULE AutoExtractPrj
		"Generated by AUTO_EXTRACT_TEMPLATE"

		/begin A2ML 
			/***********************************************************/
			/*                                                         */
			/* ASAP2 meta language for XCP V1.2                        */
			/*                                                         */
			/*                                                         */
			/*   Datatypes:                                            */
			/*                                                         */
			/*   A2ML       description                                */
			/*   ----------------------------------------------------- */
			/*   uchar      unsigned 8  Bit                            */
			/*   char       signed 8 Bit                               */
			/*   uint       unsigned integer 16 Bit                    */
			/*   int        signed integer 16 Bit                      */
			/*   ulong      unsigned integer 32 Bit                    */
			/*   long       signed integer 32 Bit                      */
			/*   float      float 32 Bit IEEE 745                      */
			/*                                                         */
			/***********************************************************/

			/************************ start of XCP definitions *********/

			/***********************************************************/
			/*                                                         */
			/* ASAP2 meta language for XCP protocol layer V1.2         */
			/*                                                         */
			/*                                                         */
			/*   Datatypes:                                            */
			/*                                                         */
			/*   A2ML       description                                */
			/*   ----------------------------------------------------- */
			/*   uchar      unsigned 8  Bit                            */
			/*   char       signed 8 Bit                               */
			/*   uint       unsigned integer 16 Bit                    */
			/*   int        signed integer 16 Bit                      */
			/*   ulong      unsigned integer 32 Bit                    */
			/*   long       signed integer 32 Bit                      */
			/*   float      float 32 Bit IEEE 745                      */
			/*                                                         */
			/***********************************************************/

			/*************** start of PROTOCOL_LAYER *******************/ 
			
			struct Protocol_Layer {     /* At MODULE */ 
				
				uint;                                /* XCP protocol layer version */ 
				/* e.g. "1.2" = 0x0102            */ 
				
				uint;                                /* T1 [ms] */ 
				uint;                                /* T2 [ms] */ 
				uint;                                /* T3 [ms] */ 
				uint;                                /* T4 [ms] */ 
				uint;                                /* T5 [ms] */ 
				uint;                                /* T6 [ms] */ 
				uint;                                /* T7 [ms] */ 
				
				uchar;                               /* MAX_CTO */ 
				uint;                                /* MAX_DTO default for DAQ and STIM */ 
				
				enum {                               /* BYTE_ORDER */ 
					"BYTE_ORDER_MSB_LAST"  = 0, 
					"BYTE_ORDER_MSB_FIRST" = 1 
				}; 
				
				enum {                               /* ADDRESS_GRANULARITY */ 
					"ADDRESS_GRANULARITY_BYTE"    = 1, 
					"ADDRESS_GRANULARITY_WORD"    = 2, 
					"ADDRESS_GRANULARITY_DWORD"   = 4 
				}; 
				
				taggedstruct {                       /* optional                     */ 
					
					("OPTIONAL_CMD" enum {             /* XCP-Code of optional command */  
						/* supported by the slave       */ 
						
						"GET_COMM_MODE_INFO"       = 0xFB, 
						"GET_ID"                   = 0xFA, 
						"SET_REQUEST"              = 0xF9, 
						"GET_SEED"                 = 0xF8, 
						"UNLOCK"                   = 0xF7, 
						"SET_MTA"                  = 0xF6, 
						"UPLOAD"                   = 0xF5, 
						"SHORT_UPLOAD"             = 0xF4, 
						"BUILD_CHECKSUM"           = 0xF3, 
						"TRANSPORT_LAYER_CMD"      = 0xF2, 
						"USER_CMD"                 = 0xF1, 
						"DOWNLOAD"                 = 0xF0, 
						"DOWNLOAD_NEXT"            = 0xEF, 
						"DOWNLOAD_MAX"             = 0xEE, 
						"SHORT_DOWNLOAD"           = 0xED, 
						"MODIFY_BITS"              = 0xEC, 
						"SET_CAL_PAGE"             = 0xEB, 
						"GET_CAL_PAGE"             = 0xEA, 
						"GET_PAG_PROCESSOR_INFO"   = 0xE9, 
						"GET_SEGMENT_INFO"         = 0xE8, 
						"GET_PAGE_INFO"            = 0xE7, 
						"SET_SEGMENT_MODE"         = 0xE6, 
						"GET_SEGMENT_MODE"         = 0xE5, 
						"COPY_CAL_PAGE"            = 0xE4, 
						"CLEAR_DAQ_LIST"           = 0xE3, 
						"SET_DAQ_PTR"              = 0xE2, 
						"WRITE_DAQ"                = 0xE1, 
						"SET_DAQ_LIST_MODE"        = 0xE0, 
						"GET_DAQ_LIST_MODE"        = 0xDF, 
						"START_STOP_DAQ_LIST"      = 0xDE, 
						"START_STOP_SYNCH"         = 0xDD, 
						"GET_DAQ_CLOCK"            = 0xDC, 
						"READ_DAQ"                 = 0xDB, 
						"GET_DAQ_PROCESSOR_INFO"   = 0xDA, 
						"GET_DAQ_RESOLUTION_INFO"  = 0xD9, 
						"GET_DAQ_LIST_INFO"        = 0xD8, 
						"GET_DAQ_EVENT_INFO"       = 0xD7, 
						"FREE_DAQ"                 = 0xD6, 
						"ALLOC_DAQ"                = 0xD5, 
						"ALLOC_ODT"                = 0xD4, 
						"ALLOC_ODT_ENTRY"          = 0xD3, 
						"PROGRAM_START"            = 0xD2, 
						"PROGRAM_CLEAR"            = 0xD1, 
						"PROGRAM"                  = 0xD0, 
						"PROGRAM_RESET"            = 0xCF, 
						"GET_PGM_PROCESSOR_INFO"   = 0xCE, 
						"GET_SECTOR_INFO"          = 0xCD, 
						"PROGRAM_PREPARE"          = 0xCC, 
						"PROGRAM_FORMAT"           = 0xCB, 
						"PROGRAM_NEXT"             = 0xCA, 
						"PROGRAM_MAX"              = 0xC9, 
						"PROGRAM_VERIFY"           = 0xC8,
						"WRITE_DAQ_MULTIPLE"       = 0xC7
					})*;           
					
					"COMMUNICATION_MODE_SUPPORTED" taggedunion { /* optional modes supported */ 
						"BLOCK" taggedstruct { 
							"SLAVE";                  /* Slave Block Mode supported  */ 
							"MASTER" struct {         /* Master Block Mode supported */ 
								uchar;  /* MAX_BS */ 
								uchar;  /* MIN_ST */ 
							}; 
						}; 
						"INTERLEAVED" uchar;    /* QUEUE_SIZE */  
					}; 
					
					"SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];  /* Name of the Seed&Key function */ 
					/* including file extension      */ 
					/* without path                  */ 
					"MAX_DTO_STIM" uint;     /* overrules MAX_DTO see above for STIM use case */                                           
				}; 
				
			};

			/***************** end of PROTOCOL_LAYER *******************/ 


			/*********************** start of DAQ **********************/ 

			struct Daq {                         /* DAQ supported, at MODULE*/ 
				enum {                             /* DAQ_CONFIG_TYPE */ 
					"STATIC"  = 0, 
					"DYNAMIC" = 1 
				}; 
				
				uint;                               /* MAX_DAQ */ 
				uint;                               /* MAX_EVENT_CHANNEL */ 
				uchar;                              /* MIN_DAQ */ 
				
				enum {                            /* OPTIMISATION_TYPE */ 
					"OPTIMISATION_TYPE_DEFAULT"            = 0, 
					"OPTIMISATION_TYPE_ODT_TYPE_16"        = 1, 
					"OPTIMISATION_TYPE_ODT_TYPE_32"        = 2, 
					"OPTIMISATION_TYPE_ODT_TYPE_64"        = 3, 
					"OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4, 
					"OPTIMISATION_TYPE_MAX_ENTRY_SIZE"     = 5 
				}; 
				
				enum {                           /* ADDRESS_EXTENSION */ 
					"ADDRESS_EXTENSION_FREE" = 0, 
					"ADDRESS_EXTENSION_ODT"  = 1, 
					"ADDRESS_EXTENSION_DAQ"  = 3 
				}; 
				
				
				enum {                           /* IDENTIFICATION_FIELD */ 
					"IDENTIFICATION_FIELD_TYPE_ABSOLUTE"              = 0, 
					"IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE"         = 1, 
					"IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD"         = 2, 
					"IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3 
				}; 
				
				
				enum {                        /* GRANULARITY_ODT_ENTRY_SIZE_DAQ */ 
					"GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE"    = 1, 
					"GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD"    = 2, 
					"GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD"   = 4, 
					"GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG"   = 8 
				}; 
				
				uchar;                              /* MAX_ODT_ENTRY_SIZE_DAQ */ 
				
				enum {                              /* OVERLOAD_INDICATION */ 
					"NO_OVERLOAD_INDICATION"    = 0, 
					"OVERLOAD_INDICATION_PID"   = 1, 
					"OVERLOAD_INDICATION_EVENT" = 2 
				}; 
				
				taggedstruct {                      /* optional */ 
					"DAQ_ALTERNATING_SUPPORTED" uint; /* Display_Event_Channel_Number */
					"PRESCALER_SUPPORTED"; 
					"RESUME_SUPPORTED"; 
					"STORE_DAQ_SUPPORTED";
					
					block "STIM" struct {             /* STIM supported */ 
						
						enum {                      /* GRANULARITY_ODT_ENTRY_SIZE_STIM */ 
							"GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE"   = 1, 
							"GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD"   = 2, 
							"GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD"  = 4, 
							"GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG"  = 8 
						}; 
						
						uchar;                          /* MAX_ODT_ENTRY_SIZE_STIM */ 
						
						taggedstruct {                  /* bitwise stimulation */ 
							"BIT_STIM_SUPPORTED"; 
							"MIN_ST_STIM" uchar; /* separation time between DTOs */
							/* time in units of 100 microseconds */
						}; 
					}; 
					
					block "TIMESTAMP_SUPPORTED" struct {  
						uint;                           /* TIMESTAMP_TICKS */ 
						enum { /* TIMESTAMP_SIZE */ 
							"NO_TIME_STAMP" = 0, 
							"SIZE_BYTE"     = 1, 
							"SIZE_WORD"     = 2, 
							"SIZE_DWORD"    = 4 
						}; 
						enum { /* RESOLUTION OF TIMESTAMP */ 
							"UNIT_1NS"   = 0, 
							"UNIT_10NS"  = 1, 
							"UNIT_100NS" = 2, 
							"UNIT_1US"   = 3, 
							"UNIT_10US"  = 4, 
							"UNIT_100US" = 5, 
							"UNIT_1MS"   = 6, 
							"UNIT_10MS"  = 7, 
							"UNIT_100MS" = 8, 
							"UNIT_1S"    = 9, 
							"UNIT_1PS"   = 10,
							"UNIT_10PS"  = 11,
							"UNIT_100PS" = 12
						}; 
						taggedstruct { 
							"TIMESTAMP_FIXED"; 
						}; 
					}; 
					
					"PID_OFF_SUPPORTED";
					
					"MAX_DAQ_TOTAL" uint;
					"MAX_ODT_TOTAL" uint;
					"MAX_ODT_DAQ_TOTAL" uint;
					"MAX_ODT_STIM_TOTAL" uint;
					"MAX_ODT_ENTRIES_TOTAL" uint;
					"MAX_ODT_ENTRIES_DAQ_TOTAL" uint;
					"MAX_ODT_ENTRIES_STIM_TOTAL" uint;

					
					"CPU_LOAD_MAX_TOTAL" float;
					
					block "DAQ_MEMORY_CONSUMPTION" struct {
						ulong; /* "DAQ_MEMORY_LIMIT"		: in Elements[AG] */
						uint;  /* "DAQ_SIZE" 			: Anzahl Elements[AG] pro DAQ-Liste */
						uint;  /* "ODT_SIZE" 			: Anzahl Elements[AG] pro ODT */
						uint;  /* "ODT_ENTRY_SIZE" 		: Anzahl Elements[AG] pro ODT_Entry */
						uint;  /* "ODT_DAQ_BUFFER_ELEMENT_SIZE" : Anzahl Payload-Elements[AG]*Faktor = sizeof(Sendepuffer)[AG] */
						uint;  /* "ODT_STIM_BUFFER_ELEMENT_SIZE": Anzahl Payload-Elements[AG]*Faktor = sizeof(Empfangspuffer)[AG] */
					};
					
					/************************ start of DAQ_LIST *************************/ 
					
					(block "DAQ_LIST" struct {          /* DAQ_LIST                    */ 
						/* multiple possible           */ 
						uint;                             /* DAQ_LIST_NUMBER             */ 
						taggedstruct {                            /* optional */ 
							"DAQ_LIST_TYPE" enum {               
								"DAQ"      = 1,               /* DIRECTION = DAQ only     */ 
								"STIM"     = 2,               /* DIRECTION = STIM only    */ 
								"DAQ_STIM" = 3                /* both directions possible */ 
								/* but not simultaneously   */ 
							}; 
							
							"MAX_ODT"         uchar;        /* MAX_ODT         */ 
							"MAX_ODT_ENTRIES" uchar;        /* MAX_ODT_ENTRIES */ 
							
							"FIRST_PID" uchar;              /* FIRST_PID for this DAQ_LIST */ 
							"EVENT_FIXED" uint;             /* this DAQ_LIST always        */ 
							/* in this event               */ 
							block "PREDEFINED" taggedstruct { /* predefined                */ 
								/* not configurable DAQ_LIST */ 
								(block "ODT" struct { 
									uchar;                   /* ODT number */ 
									taggedstruct { 
										("ODT_ENTRY" struct { 
											uchar;   /* ODT_ENTRY number            */ 
											ulong;   /* address of element                 */ 
											uchar;   /* address extension of element */ 
											uchar;   /* size of element [AG]                */ 
											uchar;   /* BIT_OFFSET                          */ 
										})*; 
									}; /* end of ODT_ENTRY */ 
								})*; /* end of ODT */ 
							}; /* end of PREDEFINED */ 
						}; 
						
					})*;
					
					/********************* end of DAQ_LIST ***************************/ 
					
					/************************* start of EVENT ************************/ 
					
					(block "EVENT" struct {             /* EVENT               */ 
						/* multiple possible   */ 
						char[101];                        /* EVENT_CHANNEL_NAME       */ 
						char[9];                          /* EVENT_CHANNEL_SHORT_NAME */ 
						uint;                             /* EVENT_CHANNEL_NUMBER     */ 
						
						enum { 
							"DAQ"      = 1,                 /* only DAQ_LISTs         */ 
							/* with DIRECTION = DAQ   */ 
							"STIM"     = 2,                 /* only DAQ_LISTs         */ 
							/* with DIRECTION = STIM  */ 
							"DAQ_STIM" = 3                  /* both kind of DAQ_LISTs */ 
						}; 
						
						uchar;                            /* MAX_DAQ_LIST */ 
						uchar;                            /* EVENT_CHANNEL_TIME_CYCLE */
						uchar;                            /* EVENT_CHANNEL_TIME_UNIT */ 
						uchar;                            /* EVENT_CHANNEL_PRIORITY */ 
						taggedstruct { /* optional */
							
							"COMPLEMENTARY_BYPASS_EVENT_CHANNEL_NUMBER" uint;
							"CONSISTENCY" enum {
								
								"DAQ" = 0,
								"EVENT" = 1
							};
							
							block "MIN_CYCLE_TIME" struct { /* Configuration with 0-0 not allowed */
								uchar;                            /* EVENT_CHANNEL_TIME_CYCLE */
								uchar;                            /* EVENT_CHANNEL_TIME_UNIT  */
							};
							
							"CPU_LOAD_MAX" float;
							
							block "CPU_LOAD_CONSUMPTION_DAQ" struct {
								float;  // "DAQ_FACTOR"
								float;  // "ODT_FACTOR"
								float;  // "ODT_ENTRY_FACTOR" 
								taggedstruct { 
									(block "ODT_ENTRY_SIZE_FACTOR_TABLE" struct{// Kopierroutine
										uint; //"SIZE" 
										float; // "SIZE_FACTOR" 
									})*;
								};
							};
							
							block "CPU_LOAD_CONSUMPTION_STIM" struct {
								float;  // "DAQ_FACTOR"
								float;  // "ODT_FACTOR"
								float;  // "ODT_ENTRY_FACTOR" 
								taggedstruct { 
									(block "ODT_ENTRY_SIZE_FACTOR_TABLE" struct{// Kopierroutine
										uint; //"SIZE" 
										float; //"SIZE_FACTOR" 
									})*;
								};
							};
							
							block "CPU_LOAD_CONSUMPTION_QUEUE" struct {
								float;  // "ODT_FACTOR" 
								float;  // "ODT_ELEMENT_LOAD",length in elements[AG]
							};        
						};
					})*;
					
					/******************** end of EVENT *********************/ 
					
				}; /* end of optional at DAQ */ 
				
			}; 
			
			/********************* end of DAQ **************************/  
			

			/***************** start of DAQ_EVENT **********************/ 
			
			taggedunion Daq_Event {         /* at MEASUREMENT */ 
				"FIXED_EVENT_LIST" taggedstruct { 
					("EVENT" uint)* ; 
				}; 
				"VARIABLE" taggedstruct { 
					block "AVAILABLE_EVENT_LIST" taggedstruct { 
						("EVENT" uint)*; 
					}; 
					block "DEFAULT_EVENT_LIST" taggedstruct { 
						("EVENT" uint)*; 
					}; 
				}; 
			}; 

			/******************** end of DAQ_EVENT *********************/ 
			

			/*********************** start of PAG **********************/ 
			
			struct Pag {                  /* PAG supported, at MODULE */ 
				uchar;                      /* MAX_SEGMENTS */ 
				taggedstruct {              /* optional */ 
					"FREEZE_SUPPORTED"; 
				}; 
				
			}; 

			/*********************** end of PAG ************************/ 
			

			/*********************** start of PGM **********************/ 
			
			struct Pgm {                  /* PGM supported, at MODULE */ 
				
				enum { 
					"PGM_MODE_ABSOLUTE"                = 1, 
					"PGM_MODE_FUNCTIONAL"              = 2, 
					"PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3 
				}; 
				uchar;                               /* MAX_SECTORS */ 
				uchar;                               /* MAX_CTO_PGM */ 
				
				taggedstruct {                       /* optional                */ 
					(block "SECTOR" struct {           /* SECTOR                  */ 
						/* multiple possible       */ 
						char[101];                       /* SECTOR_NAME             */ 
						uchar;                           /* SECTOR_NUMBER           */ 
						ulong;                           /* Address                 */ 
						ulong;                           /* Length                  */ 
						uchar;                           /* CLEAR_SEQUENCE_NUMBER   */ 
						uchar;                           /* PROGRAM_SEQUENCE_NUMBER */ 
						uchar;                           /* PROGRAM_METHOD          */ 
					})*; /* end of SECTOR */ 
					
					"COMMUNICATION_MODE_SUPPORTED" taggedunion { /* optional modes supported */ 
						"BLOCK" taggedstruct { 
							"SLAVE";                  /* Slave Block Mode supported  */ 
							"MASTER" struct {         /* Master Block Mode supported */ 
								uchar;  /* MAX_BS_PGM */ 
								uchar;  /* MIN_ST_PGM */ 
							}; 
						}; 
						"INTERLEAVED" uchar;    /* QUEUE_SIZE_PGM */  
					}; 
				}; 
			}; 

			/*********************** end of PGM ************************/ 

			
			/*********************** start of SEGMENT ******************/ 
			
			struct Segment {               /* at MEMORY_SEGMENT */ 
				uchar;                               /* SEGMENT_NUMBER     */ 
				uchar;                               /* number of pages    */ 
				uchar;                               /* ADDRESS_EXTENSION  */ 
				uchar;                               /* COMPRESSION_METHOD */ 
				uchar;                               /* ENCRYPTION_METHOD  */ 
				
				taggedstruct {                       /* optional           */ 
					block "CHECKSUM" struct { 
						enum {                           /* checksum type      */ 
							"XCP_ADD_11"       =   1, 
							"XCP_ADD_12"       =   2, 
							"XCP_ADD_14"       =   3, 
							"XCP_ADD_22"       =   4, 
							"XCP_ADD_24"       =   5, 
							"XCP_ADD_44"       =   6, 
							"XCP_CRC_16"       =   7, 
							"XCP_CRC_16_CITT"  =   8, 
							"XCP_CRC_32"       =   9, 
							"XCP_USER_DEFINED" = 255 
						}; 
						
						taggedstruct { 
							"MAX_BLOCK_SIZE"              ulong ;    /* maximum block size            */ 
							/* for checksum calculation      */ 
							"EXTERNAL_FUNCTION" char[256];           /* Name of the Checksum function */ 
							/* including file extension      */ 
							/* without path                  */ 
						}; 
					}; 
					
					(block "PAGE" struct {               /* PAGES for this SEGMENT */ 
						/* multiple possible      */ 
						uchar;                             /* PAGE_NUMBER            */ 
						
						enum {            /* ECU_ACCESS_TYPE */ 
							"ECU_ACCESS_NOT_ALLOWED"      = 0, 
							"ECU_ACCESS_WITHOUT_XCP_ONLY" = 1, 
							"ECU_ACCESS_WITH_XCP_ONLY"    = 2, 
							"ECU_ACCESS_DONT_CARE"        = 3 
						}; 
						
						enum {       /* XCP_READ_ACCESS_TYPE */ 
							"XCP_READ_ACCESS_NOT_ALLOWED"      = 0, 
							"XCP_READ_ACCESS_WITHOUT_ECU_ONLY" = 1, 
							"XCP_READ_ACCESS_WITH_ECU_ONLY"    = 2, 
							"XCP_READ_ACCESS_DONT_CARE"        = 3 
						}; 
						
						enum {      /* XCP_WRITE_ACCESS_TYPE */ 
							"XCP_WRITE_ACCESS_NOT_ALLOWED"      = 0, 
							"XCP_WRITE_ACCESS_WITHOUT_ECU_ONLY" = 1, 
							"XCP_WRITE_ACCESS_WITH_ECU_ONLY"    = 2, 
							"XCP_WRITE_ACCESS_DONT_CARE"        = 3 
						}; 
						taggedstruct { 
							"INIT_SEGMENT" uchar; /* references segment that initialises this page */ 
						}; 
						
					})*; /* end of PAGE */                 
					
					(block "ADDRESS_MAPPING" struct {  /* multiple possible   */ 
						ulong;        /* source address      */ 
						ulong;        /* destination address */ 
						ulong;        /* length              */ 
					})*; 
					
					"PGM_VERIFY" ulong; /* verification value for PGM */ 
				}; /* end of optional */ 
				
			}; 

			/************************ end of SEGMENT *******************/ 

			
			/*********************** start of Common Parameters ********/ 
			
			taggedstruct Common_Parameters {  
				
				block "PROTOCOL_LAYER" struct Protocol_Layer; 
				
				block "SEGMENT" struct Segment; 
				
				block "DAQ" struct Daq; 
				block "PAG" struct Pag; 
				block "PGM" struct Pgm; 
				
				block "DAQ_EVENT" taggedunion Daq_Event; 
				
			}; 

			/********************** end of Common Parameters **********/ 


			/***********************************************************/
			/*                                                         */
			/* ASAP2 meta language for XCP on CAN V1.2                 */
			/*                                                         */
			/*                                                         */
			/*   Datatypes:                                            */
			/*                                                         */
			/*   A2ML       description                                */
			/*   ----------------------------------------------------- */
			/*   uchar      unsigned 8  Bit                            */
			/*   char       signed 8 Bit                               */
			/*   uint       unsigned integer 16 Bit                    */
			/*   int        signed integer 16 Bit                      */
			/*   ulong      unsigned integer 32 Bit                    */
			/*   long       signed integer 32 Bit                      */
			/*   float      float 32 Bit IEEE 745                      */
			/*                                                         */
			/***********************************************************/
			/************************ start of CAN *********************/

			struct CAN_Parameters { /* At MODULE */
				uint; /* XCP on CAN version */
				/* e.g. "1.2" = 0x0102 */
				taggedstruct { /* optional */
					"CAN_ID_BROADCAST" ulong; /* Auto detection CAN-ID */
					/* master -> slaves */
					/* Bit31= 1: extended identifier */
					"CAN_ID_MASTER" ulong;    /* CMD/STIM CAN-ID */
					/* master -> slave */
					/* Bit31= 1: extended identifier */
					"CAN_ID_MASTER_INCREMENTAL";     /* master uses range of CAN-IDs  */
					/* start of range = CAN_ID_MASTER */
					/* end of range = CAN_ID_MASTER+MAX_BS(_PGM)-1 */
					"CAN_ID_SLAVE" ulong;     /* RES/ERR/EV/SERV/DAQ CAN-ID */
					/* slave -> master */
					/* Bit31= 1: extended identifier */
					"BAUDRATE" ulong;         /* BAUDRATE [Hz] */
					"SAMPLE_POINT" uchar;     /* sample point */
					/* [%% complete bit time] */
					"SAMPLE_RATE" enum {
						"SINGLE" = 1,           /* 1 sample per bit */
						"TRIPLE" = 3            /* 3 samples per bit */
					};
					"BTL_CYCLES" uchar;       /* BTL_CYCLES */
					/* [slots per bit time] */
					"SJW" uchar;              /* length synchr. segment */
					/* [BTL_CYCLES] */
					"SYNC_EDGE" enum {
						"SINGLE" = 1,           /* on falling edge only */
						"DUAL" = 2              /* on falling and rising edge */
					};
					"MAX_DLC_REQUIRED";       /* master to slave frames */
					/* always to have DLC = MAX_DLC = 8 */
					
					(block "DAQ_LIST_CAN_ID" struct { /* At IF_DATA DAQ */
						uint;                   /* reference to DAQ_LIST_NUMBER */
						taggedstruct {          /* exclusive tags */
							/* either VARIABLE or FIXED */
							"VARIABLE";
							"FIXED" ulong;        /* this DAQ_LIST always */
							/* on this CAN_ID */
						};
					})*;
					(block "EVENT_CAN_ID_LIST" struct { /* At IF_DATA DAQ  */
						uint;                   /* reference to EVENT_NUMBER */
						taggedstruct {          /* exclusive tags */
							("FIXED" ulong)*;        /* this Event always on this ID */
						};
					})*;
					
					"MAX_BUS_LOAD"  ulong;    /* maximum available bus */
					/* load in percent */
					
					block "CAN_FD" struct {
						taggedstruct {

							"MAX_DLC" uint; /* 8, 12, 16, 20, 24, 32, 48 or 64 */
							"CAN_FD_DATA_TRANSFER_BAUDRATE" ulong; /* BAUDRATE [Hz] */
							
							"SAMPLE_POINT" uchar;   /* sample point receiver*/
							/* [%% complete bit time] */
							
							"BTL_CYCLES" uchar;            /* BTL_CYCLES        */
							/* [slots per bit time]   */
							"SJW" uchar;              /* length synchr. segment */
							/* [BTL_CYCLES]           */
							"SYNC_EDGE" enum {
								"SINGLE" = 1, /* on falling edge only */
								"DUAL"   = 2  /* on falling and rising edge*/
							};
							
							"MAX_DLC_REQUIRED";      /* master to slave frames */
							/* always to have DLC = MAX_DLC_for CAN-FD */
							
							"SECONDARY_SAMPLE_POINT" uchar;/* sender sample point */
							/* [%% complete bit time] */
							"TRANSCEIVER_DELAY_COMPENSATION" enum {
								"OFF" = 0,
								"ON" = 1
							};
							
						};
						
					};
					
				};
				
			};

			/************************* end of CAN **********************/

			/***********************************************************/
			/*                                                         */
			/* ASAP2 meta language for XCP on SXI V1.2                 */
			/*                                                         */
			/*                                                         */
			/*   Datatypes:                                            */
			/*                                                         */
			/*   A2ML       description                                */
			/*   ----------------------------------------------------- */
			/*   uchar      unsigned 8  Bit                            */
			/*   char       signed 8 Bit                               */
			/*   uint       unsigned integer 16 Bit                    */
			/*   int        signed integer 16 Bit                      */
			/*   ulong      unsigned integer 32 Bit                    */
			/*   long       signed integer 32 Bit                      */
			/*   float      float 32 Bit IEEE 745                      */
			/*                                                         */
			/***********************************************************/
			/********************** start of SxI ***********************/
			struct SxI_Parameters { /* At MODULE */
				uint;  /* XCP on SxI version */
				/* e.g. "1.2" = 0x0102 */
				ulong; /* BAUDRATE [Hz] */
				taggedstruct { /* exclusive tags */
					"ASYNCH_FULL_DUPLEX_MODE" struct {
						enum {
							"PARITY_NONE" = 0,
							"PARITY_ODD" = 1,
							"PARITY_EVEN" = 2
						};
						enum {
							"ONE_STOP_BIT" = 1,
							"TWO_STOP_BITS" = 2
						};
					};
					"SYNCH_FULL_DUPLEX_MODE_BYTE";
					"SYNCH_FULL_DUPLEX_MODE_WORD";
					"SYNCH_FULL_DUPLEX_MODE_DWORD";
					"SYNCH_MASTER_SLAVE_MODE_BYTE";
					"SYNCH_MASTER_SLAVE_MODE_WORD";
					"SYNCH_MASTER_SLAVE_MODE_DWORD";
				};
				enum {
					"HEADER_LEN_BYTE" = 0,
					"HEADER_LEN_CTR_BYTE" = 1,
					"HEADER_LEN_FILL_BYTE" = 2,
					"HEADER_LEN_WORD" = 3,
					"HEADER_LEN_CTR_WORD" = 4,
					"HEADER_LEN_FILL_WORD" = 5
				};
				enum {
					"NO_CHECKSUM" = 0,
					"CHECKSUM_BYTE" = 1,
					"CHECKSUM_WORD" = 2
				};
				
			};

			/*************************** end of SxI ********************/


			/***********************************************************/
			/*                                                         */
			/* ASAP2 meta language for XCP on TCP_IP V1.2              */
			/*                                                         */
			/*                                                         */
			/*   Datatypes:                                            */
			/*                                                         */
			/*   A2ML       description                                */
			/*   ----------------------------------------------------- */
			/*   uchar      unsigned 8  Bit                            */
			/*   char       signed 8 Bit                               */
			/*   uint       unsigned integer 16 Bit                    */
			/*   int        signed integer 16 Bit                      */
			/*   ulong      unsigned integer 32 Bit                    */
			/*   long       signed integer 32 Bit                      */
			/*   float      float 32 Bit IEEE 745                      */
			/*                                                         */
			/***********************************************************/
			/************************ start of TCP_IP ******************/

			struct TCP_IP_Parameters {

				uint; /* XCP on UDP_IP version */
				/* e.g. "1.2" = 0x0102 */
				uint; /* PORT */

				taggedunion {
					"HOST_NAME" char[256];
					"ADDRESS" char[15];
					"IPV6" char[39];
				};
				taggedstruct{
					"MAX_BUS_LOAD"  ulong; /* maximum available bus */
					/* load in percent */
					"MAX_BIT_RATE"  ulong; /* Network speed which is */ 
					/* the base for MAX_BUS_LOAD in Mbit*/

				};

			};

			/************************* end of TCP_IP *******************/


			/***********************************************************/
			/*                                                         */
			/* ASAP2 meta language for XCP on TCP_IP V1.2              */
			/*                                                         */
			/*                                                         */
			/*   Datatypes:                                            */
			/*                                                         */
			/*   A2ML       description                                */
			/*   ----------------------------------------------------- */
			/*   uchar      unsigned 8  Bit                            */
			/*   char       signed 8 Bit                               */
			/*   uint       unsigned integer 16 Bit                    */
			/*   int        signed integer 16 Bit                      */
			/*   ulong      unsigned integer 32 Bit                    */
			/*   long       signed integer 32 Bit                      */
			/*   float      float 32 Bit IEEE 745                      */
			/*                                                         */
			/***********************************************************/
			/************************ start of UDP_IP ******************/

			struct UDP_IP_Parameters {

				uint; /* XCP on UDP_IP version */
				/* e.g. "1.2" = 0x0102 */
				uint; /* PORT */

				taggedunion {
					"HOST_NAME" char[256];
					"ADDRESS" char[15];
					"IPV6" char[39];
				};
				taggedstruct{
					"MAX_BUS_LOAD"  ulong; /* maximum available bus */
					/* load in percent */
					"MAX_BIT_RATE"  ulong; /* Network speed which is */ 
					/* the base for MAX_BUS_LOAD in Mbit*/

				};

			};

			/*************************** end of UDP ********************/


			/***********************************************************/
			/*                                                         */
			/* ASAP2 meta language for XCP on USB V1.2              */
			/*                                                         */
			/*                                                         */
			/*   Datatypes:                                            */
			/*                                                         */
			/*   A2ML       description                                */
			/*   ----------------------------------------------------- */
			/*   uchar      unsigned 8  Bit                            */
			/*   char       signed 8 Bit                               */
			/*   uint       unsigned integer 16 Bit                    */
			/*   int        signed integer 16 Bit                      */
			/*   ulong      unsigned integer 32 Bit                    */
			/*   long       signed integer 32 Bit                      */
			/*   float      float 32 Bit IEEE 745                      */
			/*                                                         */
			/***********************************************************/
			/************************ start of USB *********************/

			struct ep_parameters {
				uchar;                    /* ENDPOINT_NUMBER, not endpoint address */
				enum {
					"BULK_TRANSFER"      = 2,          /* Numbers according to USB spec. */
					"INTERRUPT_TRANSFER" = 3
				};
				uint;                              /* wMaxPacketSize: Maximum packet */
				/* size of endpoint in bytes */
				uchar;                             /* bInterval: polling of endpoint */
				enum {                             /* Packing of XCP Messages */
					"MESSAGE_PACKING_SINGLE"    = 0, /* Single per USB data packet */
					"MESSAGE_PACKING_MULTIPLE"  = 1, /* Multiple per USB data packet */
					"MESSAGE_PACKING_STREAMING" = 2  /* No restriction by packet sizes */
				};
				enum {                             /* Alignment mandatory for all */
					"ALIGNMENT_8_BIT" = 0,           /* packing types */
					"ALIGNMENT_16_BIT"= 1,
					"ALIGNMENT_32_BIT"= 2,
					"ALIGNMENT_64_BIT"= 3
				};
				taggedstruct {                     /* Optional */
					"RECOMMENDED_HOST_BUFSIZE" uint; /* Recommended size for the host */
					/* buffer size. The size is defined*/
					/* as multiple of wMaxPacketSize. */
				};
			}; /* end of ep_parameters */
			
			struct USB_Parameters {
				uint;                              /* XCP on USB version */
				/* e.g. 1.0 = 0x0101 */
				uint;                              /* Vendor ID */
				uint;                              /* Product ID */
				uchar;                             /* Number of interface */
				enum {
					"HEADER_LEN_BYTE"      = 0,
					"HEADER_LEN_CTR_BYTE"  = 1,
					"HEADER_LEN_FILL_BYTE"  = 2,
					"HEADER_LEN_WORD"      = 3,
					"HEADER_LEN_CTR_WORD"  = 4,
					"HEADER_LEN_FILL_WORD" = 5
				};
				taggedunion {                      /* OUT-EP for CMD and */
					/* STIM (if not specified otherwise) */
					block "OUT_EP_CMD_STIM" struct ep_parameters;
				};
				taggedunion {                      /* IN-EP for RES/ERR, */
					/* DAQ (if not specified otherwise) and */
					/* EV/SERV (if not specified otherwise) */
					block "IN_EP_RESERR_DAQ_EVSERV" struct ep_parameters;
				};
				/* ----------- Begin of optional ------- */
				taggedstruct { /* Optional */
					"ALTERNATE_SETTING_NO" uchar;    /* Number of alternate setting */
					/* String Descriptor of XCP */
					/* interface */
					"INTERFACE_STRING_DESCRIPTOR" char [101];
					/* multiple OUT-EP's for STIM */
					(block "OUT_EP_ONLY_STIM" struct ep_parameters)*;
					/* multiple IN-EP's for DAQ */
					(block "IN_EP_ONLY_DAQ" struct ep_parameters)*;
					/* only one IN-EP for EV/SERV */
					block "IN_EP_ONLY_EVSERV" struct ep_parameters;
					(block "DAQ_LIST_USB_ENDPOINT" struct {
						uint;                          /* reference to DAQ_LIST_NUMBER */
						taggedstruct {                 /* only mentioned if not VARIABLE */
							"FIXED_IN" uchar;            /* this DAQ list always */
							/* ENDPOINT_NUMBER, not endpoint address */
							"FIXED_OUT" uchar;           /* this STIM list always */
							/* ENDPOINT_NUMBER, not endpoint address */
						};
					})*; /* end of DAQ_LIST_USB_ENDPOINT */
				}; /* end of optional */
			};

			/************************* end of USB **********************/


			/***********************************************************/
			/*                                                         */
			/* ASAP2 meta language for XCP on FLX V1.2                 */
			/*                                                         */
			/*                                                         */
			/*   Datatypes:                                            */
			/*                                                         */
			/*   A2ML       description                                */
			/*   ----------------------------------------------------- */
			/*   uchar      unsigned 8  Bit                            */
			/*   char       signed 8 Bit                               */
			/*   uint       unsigned integer 16 Bit                    */
			/*   int        signed integer 16 Bit                      */
			/*   ulong      unsigned integer 32 Bit                    */
			/*   long       signed integer 32 Bit                      */
			/*   float      float 32 Bit IEEE 745                      */
			/*                                                         */
			/***********************************************************/
			/************************ start of FLX *********************/
			
			enum packet_assignment_type {
				"NOT_ALLOWED",
				"FIXED",
				"VARIABLE_INITIALISED",
				"VARIABLE"
			}; /* end of packet_assignment_type */
			
			struct buffer {
				
				uchar;  /* FLX_BUF */
				
				taggedstruct {
					
					"MAX_FLX_LEN_BUF" taggedunion {
						"FIXED" uchar;    /* constant value */
						"VARIABLE" uchar; /* initial value */
					}; /* end of MAX_FLX_LEN_BUF */
					
					block "LPDU_ID" taggedstruct {
						
						"FLX_SLOT_ID" taggedunion {
							"FIXED" uint;
							"VARIABLE" taggedstruct{
								"INITIAL_VALUE" uint;
							};
						}; /* end of FLX_SLOT_ID */
						
						"OFFSET" taggedunion {
							"FIXED" uchar;
							"VARIABLE" taggedstruct{
								"INITIAL_VALUE" uchar;
							};
						}; /* end of OFFSET */
						
						"CYCLE_REPETITION" taggedunion {
							"FIXED" uchar;
							"VARIABLE" taggedstruct{
								"INITIAL_VALUE" uchar;
							};
						}; /* end of CYCLE_REPETITION */
						
						"CHANNEL" taggedunion {
							"FIXED" enum {
								"A" = 0,
								"B" = 1
							};
							"VARIABLE" taggedstruct{
								"INITIAL_VALUE" enum {
									"A" = 0,
									"B" = 1
								};
							};
						}; /* end of CHANNEL */
						
					}; /* end of LPDU_ID */
					
					block "XCP_PACKET" taggedstruct {
						
						"CMD" enum packet_assignment_type;          /* end of CMD          */
						"RES_ERR" enum packet_assignment_type;  /* end of RES_ERR */
						"EV_SERV" enum packet_assignment_type;  /* end of EV_SERV  */
						"DAQ" enum packet_assignment_type;           /* end of DAQ           */
						"STIM" enum packet_assignment_type;          /* end of STIM          */
						
					}; /* end of XCP_PACKET */
				}; 
				
			}; /* end of buffer */
			
			struct FLX_Parameters {
				
				uint;                              /* XCP on FlexRay version  */
				/* e.g. "1.0" = 0x0100 */
				
				uint;                          /* T1_FLX [ms] */
				
				char[256];                     /* FIBEX-file including CHI information */
				/* including extension    */
				/* without path */
				
				char[256];                     /* Cluster-ID */
				
				uchar;                         /* NAX */
				
				enum { 
					"HEADER_NAX"               = 0,
					"HEADER_NAX_FILL"          = 1,
					"HEADER_NAX_CTR"           = 2,
					"HEADER_NAX_FILL3"         = 3,
					"HEADER_NAX_CTR_FILL2"     = 4,
					"HEADER_NAX_LEN"           = 5,
					"HEADER_NAX_CTR_LEN"       = 6,
					"HEADER_NAX_FILL2_LEN"     = 7,
					"HEADER_NAX_CTR_FILL_LEN"  = 8
				};
				
				
				enum { 
					"PACKET_ALIGNMENT_8"  = 0,
					"PACKET_ALIGNMENT_16" = 1,
					"PACKET_ALIGNMENT_32" = 2
				};
				
				taggedunion {
					block "INITIAL_CMD_BUFFER" struct buffer;
				};
				
				taggedunion {    
					block "INITIAL_RES_ERR_BUFFER" struct buffer;
				};
				
				taggedstruct {
					
					(block "POOL_BUFFER" struct buffer)*;
					
				};
				
			};
			
			/************************* end of FLX **********************/


			/************************ end of XCP definitions ***********/



			block "IF_DATA" taggedunion if_data {
				"ETAS_CAL_METHOD" taggedstruct {
					(block "CAL_PARAM_GROUP" taggedstruct {
						"NAME"     char[1024];
						"ADDRESS"  ulong;
						"SIZE"     ulong;
					})*;
				};


				
				/************* start of XCP on different Transport Layers *******************/

				"XCPplus" struct {
					uint;
					taggedstruct Common_Parameters ; /* default parameters */

					taggedstruct { /* transport layer specific parameters  */
						/* overruling of the default parameters */

						(block "XCP_ON_CAN" struct {

							struct CAN_Parameters ;                   /* specific for CAN      */
							taggedstruct Common_Parameters;           /* overruling of default */
							taggedstruct {
								"TRANSPORT_LAYER_INSTANCE" char[101];
							};

						})*;

						(block "XCP_ON_SxI" struct {

							struct SxI_Parameters ;                   /* specific for SPI      */
							taggedstruct Common_Parameters;           /* overruling of default */
							taggedstruct {
								"TRANSPORT_LAYER_INSTANCE" char[101];
							};

						})*;

						(block "XCP_ON_TCP_IP" struct {

							struct TCP_IP_Parameters ;                /* specific for TCP_IP   */
							taggedstruct Common_Parameters;           /* overruling of default */
							taggedstruct {
								"TRANSPORT_LAYER_INSTANCE" char[101];
							};

						})*;

						(block "XCP_ON_UDP_IP" struct {

							struct UDP_IP_Parameters ;                /* specific for UDP      */
							taggedstruct Common_Parameters;           /* overruling of default */
							taggedstruct {
								"TRANSPORT_LAYER_INSTANCE" char[101];
							};

						})*;

						(block "XCP_ON_USB" struct {

							struct USB_Parameters ;                   /* specific for USB      */
							taggedstruct Common_Parameters;           /* overruling of default */
							taggedstruct {
								"TRANSPORT_LAYER_INSTANCE" char[101];
							};

						})*;

						(block "XCP_ON_FLX" struct {

							struct FLX_Parameters ;                   /* specific for FLX      */
							taggedstruct Common_Parameters;           /* overruling of default */
							taggedstruct {
								"TRANSPORT_LAYER_INSTANCE" char[101];
							};

						})*;

					};

				};/************* end of XCP on different Transport Layers ********************/






			};


		/end A2ML


		/begin MOD_PAR
			""
			VERSION "V1.0"  
			SUPPLIER "Template"  
			CUSTOMER "Template"  
			CUSTOMER_NO "Template"  
			USER "Template"
			PHONE_NO ""  
			ECU "Template"
			CPU_TYPE "Template"
			NO_OF_INTERFACES 1 







                        // -----------------------------------------------------
			/begin MEMORY_SEGMENT CAL "CAL" DATA FLASH INTERN 0x28085800 0x8000 -1 -1 -1 -1 -1
				/begin IF_DATA XCPplus 0x0102
					/begin SEGMENT
						0x00 /* segment logical number */
						0x02 /* number of pages */
						0x00 /* address extension */
						0x00 /* compression method */
						0x00 /* encryption method */
						/begin CHECKSUM
							XCP_ADD_12
						/end CHECKSUM
						/begin PAGE
							0x00 /* page number RP */
							ECU_ACCESS_WITH_XCP_ONLY
							XCP_READ_ACCESS_WITH_ECU_ONLY
							XCP_WRITE_ACCESS_NOT_ALLOWED /* By this option, this memory page is Reference Page! */
						/end PAGE
						/begin PAGE
							0x01 /* page number WP */
							ECU_ACCESS_WITH_XCP_ONLY
							XCP_READ_ACCESS_WITH_ECU_ONLY
							XCP_WRITE_ACCESS_WITH_ECU_ONLY /* By this option, this memory page is Working Page! */
						/end PAGE
                       /begin ADDRESS_MAPPING 
                       0x28085800 
                       0x28085800 
                       0x8000 
                     /end ADDRESS_MAPPING 
					/end SEGMENT
				/end IF_DATA
			/end MEMORY_SEGMENT






		/end MOD_PAR

		/begin MOD_COMMON 
			"Common definitions" 
			BYTE_ORDER MSB_LAST
			ALIGNMENT_BYTE 1 
			ALIGNMENT_WORD 2 
			ALIGNMENT_LONG 4
			ALIGNMENT_FLOAT32_IEEE 4
			ALIGNMENT_FLOAT64_IEEE 8 
		/end MOD_COMMON


		/begin IF_DATA XCPplus 0x0102           /* Insert this block within the MODULE block of the A2L file. */

			/begin PROTOCOL_LAYER
	
				0x0102					/* XCP protocol layer Version, 0x0100 = 1.0, 0x0101 = 1.1, 0x0102 = 1.2 */

				2000                  /* T1 ms = default Timeout for most CMDs */
				2000                  /* T2 ms = Timeout for Build Checksum */
				2000                  /* T3 ms = Timeout for Program - Start, - Prepare, - Verify */
				60000                  /* T4 ms = Timeout for Program Clear */ /* T4 [ms] */
				2000                  /* T5 ms = Timeout for Program, - Reset, -Max */
				0005                  /* T6 ms = RepeatTimeout between "CONNECT(USER_DEFINED)" */
				0005                  /* T7 ms = Timeout for PreAction after CMD - Timeout (Master) */

				8                     /* MAX_CTO */
				8                     /* MAX_DTO */

				BYTE_ORDER_MSB_LAST
				ADDRESS_GRANULARITY_BYTE

				OPTIONAL_CMD GET_COMM_MODE_INFO
				OPTIONAL_CMD SET_REQUEST
				OPTIONAL_CMD SET_MTA
				OPTIONAL_CMD UPLOAD
				OPTIONAL_CMD SHORT_UPLOAD
				/*OPTIONAL_CMD BUILD_CHECKSUM */
				OPTIONAL_CMD DOWNLOAD
				OPTIONAL_CMD MODIFY_BITS
				OPTIONAL_CMD SET_CAL_PAGE
				OPTIONAL_CMD GET_CAL_PAGE
				OPTIONAL_CMD COPY_CAL_PAGE
				OPTIONAL_CMD CLEAR_DAQ_LIST
				OPTIONAL_CMD SET_DAQ_PTR
				OPTIONAL_CMD WRITE_DAQ
				OPTIONAL_CMD SET_DAQ_LIST_MODE
				OPTIONAL_CMD START_STOP_DAQ_LIST
				OPTIONAL_CMD START_STOP_SYNCH
				OPTIONAL_CMD GET_DAQ_CLOCK


				/* DAQ is Dynamic, some optional commands are added. */

				OPTIONAL_CMD FREE_DAQ
				OPTIONAL_CMD ALLOC_DAQ
				OPTIONAL_CMD ALLOC_ODT
				OPTIONAL_CMD ALLOC_ODT_ENTRY




				COMMUNICATION_MODE_SUPPORTED
					BLOCK
					SLAVE
					MASTER
					0xFF    /* MAX_BS */
					100    /* MIN_ST */



			/end PROTOCOL_LAYER

			/begin DAQ

				DYNAMIC                        /* DAQ_CONFIG_TYPE */

				3                                 /* MAX_DAQ */
				3                      /* MAX_EVENT_CHANNEL */
				0                                           /* MIN_DAQ, i.e. the number of predefined DAQ lists */

				OPTIMISATION_TYPE_DEFAULT
				ADDRESS_EXTENSION_DAQ                     /* ADDR_EXTENSION_TYPE */
				IDENTIFICATION_FIELD_TYPE_ABSOLUTE

				GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE
				8                  /* MAX_ODT_ENTRY_SIZE_DAQ */

				NO_OVERLOAD_INDICATION


				/begin EVENT
					"10ms_Raster_0"                /* EVENT_CHANNEL_NAME */
					"10msRstr"          /* EVENT_CHANNEL_SHORT_NAME */
					0                /* EVENT_CHANNEL_NUMBER */
					DAQ                                     /* EVENT_CHANNEL_DIRECTION */
					0xff                                    /* MAX_DAQ_LIST */
					1            /* TIME_CYCLE */
					7             /* TIME_UNIT */
					0                                       /* PRIORITY */
				/end EVENT

				/begin EVENT
					"100ms_Raster_1"                /* EVENT_CHANNEL_NAME */
					"100msRstr"          /* EVENT_CHANNEL_SHORT_NAME */
					1                /* EVENT_CHANNEL_NUMBER */
					DAQ                                     /* EVENT_CHANNEL_DIRECTION */
					0xff                                    /* MAX_DAQ_LIST */
					1            /* TIME_CYCLE */
					8             /* TIME_UNIT */
					0                                       /* PRIORITY */
				/end EVENT

				/begin EVENT
					"1000ms_Raster_2"                /* EVENT_CHANNEL_NAME */
					"1000msRstr"          /* EVENT_CHANNEL_SHORT_NAME */
					2                /* EVENT_CHANNEL_NUMBER */
					DAQ                                     /* EVENT_CHANNEL_DIRECTION */
					0xff                                    /* MAX_DAQ_LIST */
					1            /* TIME_CYCLE */
					9             /* TIME_UNIT */
					0                                       /* PRIORITY */
				/end EVENT

			/end DAQ

			/begin PAG
				2                            /* MAX_SEGMENTS */
			/end PAG

			/begin XCP_ON_CAN

				0x0102                                      /* XCP on CAN 1.2 */
				CAN_ID_MASTER    0x6E0          /* CMD/STIM */
				CAN_ID_SLAVE     0x6E1           /* RES/ERR/EV/SERV/DAQ */
				BAUDRATE         500000               /* In Hz */
				SAMPLE_POINT     75           /* Percentage of complete bit time. */
				SAMPLE_RATE      SINGLE
				BTL_CYCLES       8             /* Slots per bit time. */
				SJW              2                    /* Length of the synch segment. */
				SYNC_EDGE        SINGLE

				/begin EVENT_CAN_ID_LIST
					0                     /* DAQ_LIST_NUMBER */
					FIXED 0x6E1                 /* CAN msg ID */
				/end EVENT_CAN_ID_LIST    
				/begin EVENT_CAN_ID_LIST
					1                     /* DAQ_LIST_NUMBER */
					FIXED 0x6E1                 /* CAN msg ID */
				/end EVENT_CAN_ID_LIST    
				/begin EVENT_CAN_ID_LIST
					2                     /* DAQ_LIST_NUMBER */
					FIXED 0x6E1                 /* CAN msg ID */
				/end EVENT_CAN_ID_LIST    


				/begin CAN_FD
					MAX_DLC 8                                         /* 8, 12, 16, 20, 24, 32, 48 or 64 */
					CAN_FD_DATA_TRANSFER_BAUDRATE 2000000                   /* BAUDRATE [Hz] */
					
					/* [% complete bit time] */
					SAMPLE_POINT 70                                    /* sample point receiver*/
					
					BTL_CYCLES 10
					
					/* [slots per bit time] */
					SJW 6                                             /* length synchr. segment */
					
					/* DUAL on falling and rising edge */
					SYNC_EDGE SINGLE                                       /* on falling edge only */
					
					/* always to have DLC = MAX_DLC_for CAN-FD */
					MAX_DLC_REQUIRED                              /* master to slave frames */
					SECONDARY_SAMPLE_POINT 50                          /* sender sample point */
					/* TRANSCEIVER_DELAY_COMPENSATION ON */            /* [% complete bit time] */
				/end CAN_FD
			/end XCP_ON_CAN


		/end IF_DATA






		// If you need your own configuration,

		// Run AutoExtractGui > Options > Custom Config,

		// describe configuration.



	/* Start of automatic variable extraction*/